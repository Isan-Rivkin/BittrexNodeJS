var q = require('q')
var id = 0;
var Node = (function () {
    function Node() {
        this._id = id++;
    }
    Object.defineProperty(Node.prototype, "id", {
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    return Node;
})();
exports.Node = Node;
var NodeList = (function () {
    function NodeList() {
        this._nodes = {
        };
        this._length = 0;
    }
    NodeList.prototype.getNode = function (id) {
        if(!this._nodes[id]) {
            return null;
        } else {
            return this._nodes[id];
        }
    };
    NodeList.prototype.addNode = function (node) {
        this._nodes[node.id] = node;
        this._length++;
    };
    NodeList.prototype.removeNode = function (node) {
        this._nodes[node.id] = undefined;
        this._length--;
    };
    NodeList.prototype.forEach = function (op) {
        for(var id in this._nodes) {
            op(this._nodes[id], this);
        }
    };
    NodeList.prototype.toArray = function () {
        var nodeArray = [];
        this.forEach(function (node) {
            return nodeArray.push(node);
        });
        return nodeArray;
    };
    Object.defineProperty(NodeList.prototype, "length", {
        get: function () {
            return this._length;
        },
        enumerable: true,
        configurable: true
    });
    return NodeList;
})();
exports.NodeList = NodeList;
var EdgeMap = (function () {
    function EdgeMap(nodes) {
        this.nodes = nodes;
        this._edges = {
        };
    }
    EdgeMap.prototype.setEdge = function (one, two, distance) {
        if(!this._edges[one.id]) {
            this._edges[one.id] = {
            };
        }
        if(!this._edges[two.id]) {
            this._edges[two.id] = {
            };
        }
        this._edges[one.id][two.id] = distance;
        this._edges[two.id][one.id] = distance;
    };
    EdgeMap.prototype.getEdge = function (one, two) {
        if(this._edges[one.id] === undefined || this._edges[one.id][two.id] === undefined) {
            return Number.POSITIVE_INFINITY;
        } else {
            return this._edges[one.id][two.id];
        }
    };
    EdgeMap.prototype.forEach = function (op) {
        var _this = this;
        _this.nodes.forEach(function (node1) {
            for(var n2id in _this._edges[node1.id]) {
                var node2 = _this.nodes.getNode(n2id);
                op(node1, node2, _this._edges[node1.id][node2.id]);
            }
        });
    };
    return EdgeMap;
})();
exports.EdgeMap = EdgeMap;
var DistanceResult = (function () {
    function DistanceResult(distance, via) {
        this.distance = distance;
        this.via = via;
    }
    DistanceResult.prototype.toString = function () {
        return "{via:" + ((this.via) ? this.via.id.toString() : '-') + ",distance:" + this.distance + "}";
    };
    return DistanceResult;
})();
exports.DistanceResult = DistanceResult;
var DistanceResultList = (function () {
    function DistanceResultList(destination) {
        this.destination = destination;
        this._distances = {
        };
        this._distances[destination.id] = new DistanceResult(0, null);
    }
    DistanceResultList.prototype.forEach = function (op) {
        var i = 0;
        for(var key in this._distances) {
            op(this._distances[key], Number(key), i++);
        }
    };
    DistanceResultList.prototype.getDistanceFrom = function (source) {
        if(!this._distances[source.id]) {
            return this._distances[source.id] = new DistanceResult(Number.POSITIVE_INFINITY, null);
        }
        return this._distances[source.id];
    };
    DistanceResultList.prototype.copy = function () {
        var c = new DistanceResultList(this.destination);
        var distances = {
        };
        for(var key in this._distances) {
            distances[key] = this._distances[key];
        }
        c._distances = distances;
        return c;
    };
    DistanceResultList.prototype.toString = function () {
        var out = "{";
        this.forEach(function (distance, id, i) {
            if(i > 0) {
                out += ',';
            }
            out += id.toString() + ":" + distance.toString();
        });
        out += "}";
        return out;
    };
    return DistanceResultList;
})();
exports.DistanceResultList = DistanceResultList;
var Graph = (function () {
    function Graph(nodes, edges) {
        this.nodes = nodes;
        this.edges = edges;
    }
    Graph.prototype.addNode = function (node) {
        this.nodes.addNode(node);
    };
    Graph.prototype.updatePaths = function (paths) {
        this.edges.forEach(function (u, v, w) {
            var uPath = paths.getDistanceFrom(u);
            var vPath = paths.getDistanceFrom(v);
            if(uPath.distance + w < vPath.distance) {
                vPath.distance = uPath.distance + w;
                vPath.via = u;
            }
        });
        return paths;
    };
    Graph.prototype.negativeCycleExists = function (paths) {
        var failure = false;
        this.edges.forEach(function (u, v, w) {
            if(paths.getDistanceFrom(u).distance + w < paths.getDistanceFrom(v).distance) {
                failure = true;
            }
        });
        return failure;
    };
    Graph.prototype.getShortestPathsAsync = function (destination) {
        var _this = this, d = q.defer();
        var shortestPaths = new DistanceResultList(destination);
        var request = q(shortestPaths);
        for(var i = 0; i < this.nodes.length - 1; i++) {
            request = request.then(function (paths) {
                d.notify(paths.copy());
                return _this.updatePaths(paths);
            });
        }
        request.then(function (paths) {
            d.notify(paths.copy());
            if(_this.negativeCycleExists(paths)) {
                d.reject(new Error("negative cycle"));
            } else {
                d.resolve(paths.copy());
            }
        });
        return d.promise;
    };
    Graph.prototype.getShortestPathsSync = function (destination) {
        var shortestPaths = new DistanceResultList(destination);
        for(var i = 0; i < this.nodes.length - 1; i++) {
            this.updatePaths(shortestPaths);
        }
        if(this.negativeCycleExists(shortestPaths)) {
            throw new Error("negative cycle");
        }
        return shortestPaths.copy();
    };
    return Graph;
})();
exports.Graph = Graph;
